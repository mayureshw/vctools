:-import
    unparse/1
    from unparsecpp.

:-import
    member/2
    from lists.

:-import
    unparse/1
    from unparsecpp.

% operators identified by vC class
vcid( 'Assign',  vcInterlockBuffer ).
vcid( 'Phi',     vcPhi             ).
vcid( 'Phi',     vcPhiPipelined    ).
vcid( 'Branch',  vcBranch          ).
vcid( 'Assign',  vcEquivalence     ).
vcid( 'Load',    vcLoad            ).
vcid( 'Store',   vcStore           ).
vcid( 'Inport',  vcInport          ).
vcid( 'Outport', vcOutport         ).
vcid( 'Call',    vcCall            ).
vcid( 'Select',  vcSelect          ).
vcid( 'Slice',   vcSlice           ).

% operators identified by vC operator
vcid( 'Plus',   '+'  ).
vcid( 'Minus',  '-'  ).
vcid( 'Mult',   '*'  ).
vcid( 'Lt',     '<'  ).
vcid( 'Gt',     '>'  ).
vcid( 'Ge',     '>=' ).
vcid( 'Ne',     '!=' ).
vcid( 'Eq',     '==' ).
vcid( 'And',    '&'  ).
vcid( 'Or',     '|'  ).
vcid( 'Not',    '~'  ).
vcid( 'Bitsel', '[]' ).
vcid( 'Concat', '&&' ).

% Presently we do not want to support airthmetic, relops for wuint
arithops( [ 'Plus', 'Minus', 'Mult' ] ).
relops( [ 'Lt', 'Gt', 'Ge', 'Ne', 'Eq' ] ).

supmtyp(O, MT) :- ( arithop(O); relop(O) ), ( MT=uint; MT=float ).

% Suport all ops. Note: in existing code floats are missing for Inport, Outport, which is a bug
univops( [ 'Assign', 'Phi', 'Load', 'Store', 'Inport', 'Outport', 'Select' ] ).

supmtyp(O, MT) :- univop(O), ( MT=uint; MT=wuint; MT=float ).

% Do not support floats
logops( [ 'And', 'Or', 'Not' ] ).

supmtyp(O, MT) :- logop(O), ( MT=uint; MT=wuint ).

% Have single instantiation with fixed template args
specialops( [ 'Bitsel', 'Concat', 'Slice', 'Branch', 'Call' ] ).

% If an operator supports a typ, it is supposed to support all subtyps
subtyps( uint,  [ uint8_t, uint16_t, uint32_t, uint64_t ] ).
subtyps( wuint, [ wuint ] ).
subtyps( float, [ float, double ] ).

%%%%%%%%%%

suptyp(O, T) :- supmtyp(O, MT), subtyp(MT, T).



% TODO
newargs.

%%%%%%%%%%

:-table subtyp/2.
subtyp(T, ST) :- subtyps(T, STs), member(ST, STs).
suf_(T, TSuf) :- str_cat(T, '_', TSuf).
:-table ctyp/1.
ctyp(ST) :- subtyp(_,ST1), suf_(ST1, ST).
:-table arithop/1.
arithop(O) :- arithops(Os), member(O, Os).
:-table relop/1.
relop(O) :- relops(Os), member(O, Os).
:-table logops/1.
logop(O) :- logops(Os), member(O, Os).
:-table specialops/1.
specialop(O) :- specialops(Os), member(O, Os).
:-table univop/1.
univop(O) :- univops(Os), member(O, Os).

% targmapv( C, Sig, lambda(Caps, 'LRET', ['LARG'], [Stmt]) ) :-
%     caps(C, Caps),
%     template(C, Sig, Targs),
%     CTyp = typ(C, Targs, ''),
%     newargs(C, Newargs),
%     Stmt = stmt(ret(new(CTyp,Newargs))).

lambdaExpr( O, ST, lambda(Caps, 'LRET', ['LARG'], [Stmt]) ) :-
    Caps = [],
    Newargs = [],
    CTyp = typ(O, [ST], ''),
    Stmt = stmt(ret(new(CTyp,Newargs))).
%template(O, VCID, [ST, ST, ST]) :-
opfmapkv( br([str(VCID),br([ST,ST,ST]), Lambda]) ) :-
    vcid(O,VCID), supmtyp(O, MT), subtyp(MT, ST1), suf_(ST1,ST),
    lambdaExpr(O,ST1,Lambda).

opfmap(br(L)) :- findall(V, opfmapkv(V), L).

cpp(def('CTYPENUM',br(L))) :- findall(TSuf, ctyp(TSuf), L1), sort(L1, L).
cpp(def('OPFMAP',Cpp)) :- opfmap(Cpp).

%%% Test drivers
:- cpp(CPP), unparse(CPP), fail.
