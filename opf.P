:-import
    unparse/1
    from unparsecpp.

:-import
    member/2
    from lists.

:-import
    unparse/1
    from unparsecpp.

% operators identified by vC class
vcid( 'Assign',  vcInterlockBuffer ).
vcid( 'Phi',     vcPhi             ).
vcid( 'Phi',     vcPhiPipelined    ).
vcid( 'Branch',  vcBranch          ).
vcid( 'Assign',  vcEquivalence     ).
vcid( 'Load',    vcLoad            ).
vcid( 'Store',   vcStore           ).
vcid( 'Inport',  vcInport          ).
vcid( 'Outport', vcOutport         ).
vcid( 'Call',    vcCall            ).
vcid( 'Select',  vcSelect          ).
vcid( 'Slice',   vcSlice           ).

% operators identified by vC operator
vcid( 'Plus',   '+'  ).
vcid( 'Minus',  '-'  ).
vcid( 'Mult',   '*'  ).
vcid( 'Lt',     '<'  ).
vcid( 'Gt',     '>'  ).
vcid( 'Ge',     '>=' ).
vcid( 'Ne',     '!=' ).
vcid( 'Eq',     '==' ).
vcid( 'And',    '&'  ).
vcid( 'Or',     '|'  ).
vcid( 'Not',    '~'  ).
vcid( 'Bitsel', '[]' ).
vcid( 'Concat', '&&' ).

% Presently we do not want to support airthmetic, relops for wuint
arithops( [ 'Plus', 'Minus', 'Mult' ] ).
relops( [ 'Lt', 'Gt', 'Ge', 'Ne', 'Eq' ] ).

supmtyp(O, MT) :- ( arithop(O); relop(O) ), ( MT=uint; MT=float ).

% Suport all ops. Note: in existing code floats are missing for Inport, Outport, which is a bug
univops( [ 'Assign', 'Phi', 'Load', 'Store', 'Inport', 'Outport', 'Select' ] ).

supmtyp(O, MT) :- univop(O), ( MT=uint; MT=wuint; MT=float ).

% Do not support floats
logops( [ 'And', 'Or', 'Not' ] ).

supmtyp(O, MT) :- logop(O), ( MT=uint; MT=wuint ).

% Have single instantiation with fixed template args
specialops( [ 'Bitsel', 'Concat', 'Slice', 'Branch', 'Call' ] ).

% If an operator supports a typ, it is supposed to support all subtyps
subtyps( uint,  [ uint8_t, uint16_t, uint32_t, uint64_t ] ).
subtyps( wuint, [ wuint ] ).
subtyps( float, [ float, double ] ).

creator('Load',create2):-!.
creator('Store',create2):-!.
creator('Inport',create2):-!.
creator('Outport',create2):-!.
creator(_,create1):-!.

%%%%%%%%%%

suptyp(O, T) :- supmtyp(O, MT), subtyp(MT, T).


:-table subtyp/2.
subtyp(T, ST) :- subtyps(T, STs), member(ST, STs).
suf_(T, TSuf) :- str_cat(T, '__', TSuf).
:-table ctyp/1.
ctyp(ST) :- subtyp(_,ST1), suf_(ST1, ST).
:-table arithop/1.
arithop(O) :- arithops(Os), member(O, Os).
:-table relop/1.
relop(O) :- relops(Os), member(O, Os).
:-table logops/1.
logop(O) :- logops(Os), member(O, Os).
:-table specialops/1.
specialop(O) :- specialops(Os), member(O, Os).
:-table univop/1.
univop(O) :- univops(Os), member(O, Os).

opfmapv( O, ST, lambda([this], 'OPRET', [ 'DPEARG' ], [Stmt]) ) :-
    CTyp = typ(O, [ST], ''), creator(O, Fcr),
    Stmt = stmt(ret(call(Fcr,[CTyp],[dpe]))).

opfmapk( VCID, ST, br( [ str(VCID), br([ST,ST,ST]) ] ) ).

opfmapkv( br( [ K, V ] ) ) :-
    vcid(O,VCID), supmtyp(O, MT), subtyp(MT, ST1), suf_(ST1, ST),
    opfmapk(VCID, ST, K), opfmapv(O, ST1, V).

opfmap(br(L)) :- findall(V, opfmapkv(V), L).

% TODO: wuint defined temporarily
cpp(def('wuint','unsigned long')).
cpp(def('CTYPENUM',br(L))) :- findall(TSuf, ctyp(TSuf), L1), sort(L1, L).
cpp(def('OPRET',typ('Operator',[],'*'))).
cpp(def('DPEARG',tv(typ('vcDatapathElement',[],'*'), [dpe]))).
cpp(def('OPFMAP',Cpp)) :- opfmap(Cpp).

%%% Test drivers
:- cpp(CPP), unparse(CPP), fail.
